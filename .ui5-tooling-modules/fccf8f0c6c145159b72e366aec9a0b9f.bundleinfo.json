{
  "_entries": [
    {
      "name": "redux",
      "path": "C:\\Users\\Adrians\\Documents\\sapui5_apps\\sapui5_redux\\node_modules\\redux\\dist\\redux.mjs",
      "lastModified": 1744095072271,
      "type": "module",
      "originalName": "redux",
      "code": "sap.ui.define(['exports'], (function (exports) { 'use strict';\n\n  // src/utils/formatProdErrorMessage.ts\n  function formatProdErrorMessage(code) {\n    return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n  }\n\n  // src/utils/symbol-observable.ts\n  var $$observable = /* @__PURE__ */ (() => typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\n  var symbol_observable_default = $$observable;\n\n  // src/utils/actionTypes.ts\n  var randomString = () => Math.random().toString(36).substring(7).split(\"\").join(\".\");\n  var ActionTypes = {\n    INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,\n    REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,\n    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`\n  };\n  var actionTypes_default = ActionTypes;\n\n  // src/utils/isPlainObject.ts\n  function isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null)\n      return false;\n    let proto = obj;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;\n  }\n\n  // src/createStore.ts\n  function createStore(reducer, preloadedState, enhancer) {\n    if (typeof reducer !== \"function\") {\n      throw new Error(formatProdErrorMessage(2) );\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n      throw new Error(formatProdErrorMessage(0) );\n    }\n    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n      enhancer = preloadedState;\n      preloadedState = void 0;\n    }\n    if (typeof enhancer !== \"undefined\") {\n      if (typeof enhancer !== \"function\") {\n        throw new Error(formatProdErrorMessage(1) );\n      }\n      return enhancer(createStore)(reducer, preloadedState);\n    }\n    let currentReducer = reducer;\n    let currentState = preloadedState;\n    let currentListeners = /* @__PURE__ */ new Map();\n    let nextListeners = currentListeners;\n    let listenerIdCounter = 0;\n    let isDispatching = false;\n    function ensureCanMutateNextListeners() {\n      if (nextListeners === currentListeners) {\n        nextListeners = /* @__PURE__ */ new Map();\n        currentListeners.forEach((listener, key) => {\n          nextListeners.set(key, listener);\n        });\n      }\n    }\n    function getState() {\n      if (isDispatching) {\n        throw new Error(formatProdErrorMessage(3) );\n      }\n      return currentState;\n    }\n    function subscribe(listener) {\n      if (typeof listener !== \"function\") {\n        throw new Error(formatProdErrorMessage(4) );\n      }\n      if (isDispatching) {\n        throw new Error(formatProdErrorMessage(5) );\n      }\n      let isSubscribed = true;\n      ensureCanMutateNextListeners();\n      const listenerId = listenerIdCounter++;\n      nextListeners.set(listenerId, listener);\n      return function unsubscribe() {\n        if (!isSubscribed) {\n          return;\n        }\n        if (isDispatching) {\n          throw new Error(formatProdErrorMessage(6) );\n        }\n        isSubscribed = false;\n        ensureCanMutateNextListeners();\n        nextListeners.delete(listenerId);\n        currentListeners = null;\n      };\n    }\n    function dispatch(action) {\n      if (!isPlainObject(action)) {\n        throw new Error(formatProdErrorMessage(7) );\n      }\n      if (typeof action.type === \"undefined\") {\n        throw new Error(formatProdErrorMessage(8) );\n      }\n      if (typeof action.type !== \"string\") {\n        throw new Error(formatProdErrorMessage(17) );\n      }\n      if (isDispatching) {\n        throw new Error(formatProdErrorMessage(9) );\n      }\n      try {\n        isDispatching = true;\n        currentState = currentReducer(currentState, action);\n      } finally {\n        isDispatching = false;\n      }\n      const listeners = currentListeners = nextListeners;\n      listeners.forEach((listener) => {\n        listener();\n      });\n      return action;\n    }\n    function replaceReducer(nextReducer) {\n      if (typeof nextReducer !== \"function\") {\n        throw new Error(formatProdErrorMessage(10) );\n      }\n      currentReducer = nextReducer;\n      dispatch({\n        type: actionTypes_default.REPLACE\n      });\n    }\n    function observable() {\n      const outerSubscribe = subscribe;\n      return {\n        /**\n         * The minimal observable subscription method.\n         * @param observer Any object that can be used as an observer.\n         * The observer object should have a `next` method.\n         * @returns An object with an `unsubscribe` method that can\n         * be used to unsubscribe the observable from the store, and prevent further\n         * emission of values from the observable.\n         */\n        subscribe(observer) {\n          if (typeof observer !== \"object\" || observer === null) {\n            throw new Error(formatProdErrorMessage(11) );\n          }\n          function observeState() {\n            const observerAsObserver = observer;\n            if (observerAsObserver.next) {\n              observerAsObserver.next(getState());\n            }\n          }\n          observeState();\n          const unsubscribe = outerSubscribe(observeState);\n          return {\n            unsubscribe\n          };\n        },\n        [symbol_observable_default]() {\n          return this;\n        }\n      };\n    }\n    dispatch({\n      type: actionTypes_default.INIT\n    });\n    const store = {\n      dispatch,\n      subscribe,\n      getState,\n      replaceReducer,\n      [symbol_observable_default]: observable\n    };\n    return store;\n  }\n  function legacy_createStore(reducer, preloadedState, enhancer) {\n    return createStore(reducer, preloadedState, enhancer);\n  }\n  function assertReducerShape(reducers) {\n    Object.keys(reducers).forEach((key) => {\n      const reducer = reducers[key];\n      const initialState = reducer(void 0, {\n        type: actionTypes_default.INIT\n      });\n      if (typeof initialState === \"undefined\") {\n        throw new Error(formatProdErrorMessage(12) );\n      }\n      if (typeof reducer(void 0, {\n        type: actionTypes_default.PROBE_UNKNOWN_ACTION()\n      }) === \"undefined\") {\n        throw new Error(formatProdErrorMessage(13) );\n      }\n    });\n  }\n  function combineReducers(reducers) {\n    const reducerKeys = Object.keys(reducers);\n    const finalReducers = {};\n    for (let i = 0; i < reducerKeys.length; i++) {\n      const key = reducerKeys[i];\n      if (typeof reducers[key] === \"function\") {\n        finalReducers[key] = reducers[key];\n      }\n    }\n    const finalReducerKeys = Object.keys(finalReducers);\n    let shapeAssertionError;\n    try {\n      assertReducerShape(finalReducers);\n    } catch (e) {\n      shapeAssertionError = e;\n    }\n    return function combination(state = {}, action) {\n      if (shapeAssertionError) {\n        throw shapeAssertionError;\n      }\n      let hasChanged = false;\n      const nextState = {};\n      for (let i = 0; i < finalReducerKeys.length; i++) {\n        const key = finalReducerKeys[i];\n        const reducer = finalReducers[key];\n        const previousStateForKey = state[key];\n        const nextStateForKey = reducer(previousStateForKey, action);\n        if (typeof nextStateForKey === \"undefined\") {\n          action && action.type;\n          throw new Error(formatProdErrorMessage(14) );\n        }\n        nextState[key] = nextStateForKey;\n        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n      }\n      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n      return hasChanged ? nextState : state;\n    };\n  }\n\n  // src/bindActionCreators.ts\n  function bindActionCreator(actionCreator, dispatch) {\n    return function(...args) {\n      return dispatch(actionCreator.apply(this, args));\n    };\n  }\n  function bindActionCreators(actionCreators, dispatch) {\n    if (typeof actionCreators === \"function\") {\n      return bindActionCreator(actionCreators, dispatch);\n    }\n    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n      throw new Error(formatProdErrorMessage(16) );\n    }\n    const boundActionCreators = {};\n    for (const key in actionCreators) {\n      const actionCreator = actionCreators[key];\n      if (typeof actionCreator === \"function\") {\n        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n      }\n    }\n    return boundActionCreators;\n  }\n\n  // src/compose.ts\n  function compose(...funcs) {\n    if (funcs.length === 0) {\n      return (arg) => arg;\n    }\n    if (funcs.length === 1) {\n      return funcs[0];\n    }\n    return funcs.reduce((a, b) => (...args) => a(b(...args)));\n  }\n\n  // src/applyMiddleware.ts\n  function applyMiddleware(...middlewares) {\n    return (createStore2) => (reducer, preloadedState) => {\n      const store = createStore2(reducer, preloadedState);\n      let dispatch = () => {\n        throw new Error(formatProdErrorMessage(15) );\n      };\n      const middlewareAPI = {\n        getState: store.getState,\n        dispatch: (action, ...args) => dispatch(action, ...args)\n      };\n      const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n      dispatch = compose(...chain)(store.dispatch);\n      return {\n        ...store,\n        dispatch\n      };\n    };\n  }\n\n  // src/utils/isAction.ts\n  function isAction(action) {\n    return isPlainObject(action) && \"type\" in action && typeof action.type === \"string\";\n  }\n\n  const __esModule = true ;\n\n  exports.__DO_NOT_USE__ActionTypes = actionTypes_default;\n  exports.__esModule = __esModule;\n  exports.applyMiddleware = applyMiddleware;\n  exports.bindActionCreators = bindActionCreators;\n  exports.combineReducers = combineReducers;\n  exports.compose = compose;\n  exports.createStore = createStore;\n  exports.isAction = isAction;\n  exports.isPlainObject = isPlainObject;\n  exports.legacy_createStore = legacy_createStore;\n\n}));\n",
      "relatedPaths": [
        "C:\\Users\\Adrians\\Documents\\sapui5_apps\\sapui5_redux\\node_modules\\redux\\dist\\redux.mjs"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false
    }
  ]
}